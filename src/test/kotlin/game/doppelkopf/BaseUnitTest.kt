package game.doppelkopf

import game.doppelkopf.adapter.persistence.model.game.GameEntity
import game.doppelkopf.adapter.persistence.model.hand.HandEntity
import game.doppelkopf.adapter.persistence.model.player.PlayerEntity
import game.doppelkopf.adapter.persistence.model.round.RoundEntity
import game.doppelkopf.adapter.persistence.model.trick.TrickEntity
import game.doppelkopf.adapter.persistence.model.turn.TurnEntity
import game.doppelkopf.adapter.persistence.model.user.UserEntity
import game.doppelkopf.core.cards.CardDemand
import game.doppelkopf.core.common.enums.Bidding
import game.doppelkopf.core.common.enums.Declaration
import io.mockk.clearAllMocks
import io.mockk.mockk
import io.mockk.unmockkAll
import org.junit.jupiter.api.BeforeAll
import org.junit.jupiter.api.TestInstance

/**
 * General case class for unit tests of this application.
 *
 * Do NOT use this class as a base class for [org.springframework.boot.test.context.SpringBootTest]!
 *
 * The entity generator methods of this class may use [mockk] and thus should not be persisted to the database!
 * Use [BaseSpringBootTest] and [BaseRestAssuredTest] for persistence backend testing instead.
 *
 * Provides basic mockk clearing and unmocking at [BeforeAll] trigger.
 */
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
abstract class BaseUnitTest {
    @BeforeAll
    fun `execute test setups and clearing to provide suitable test environment`() {
        `reset mockk`()
    }

    /**
     * Reset mockk to ensure that every test is executed without any object still mocked from previous tests.
     */
    fun `reset mockk`() {
        clearAllMocks()
        unmockkAll()
    }

    /**
     * Instantiates a new [UserEntity].
     * ENTITIES GENERATED BY THIS METHOD SHOULD NOT BE PERSISTED.
     */
    fun createUserEntity(): UserEntity {
        return UserEntity(
            username = "username",
            password = "password",
        )
    }

    /**
     * Instantiates a new [PlayerEntity].
     * ENTITIES GENERATED BY THIS METHOD SHOULD NOT BE PERSISTED.
     */
    fun createPlayerEntity(
        seat: Int = 0,
        game: GameEntity = createGameEntity(),
        user: UserEntity = createUserEntity()
    ): PlayerEntity {
        return PlayerEntity(
            user = user,
            game = game,
            seat = seat
        )
    }

    /**
     * Instantiates a new [GameEntity].
     * ENTITIES GENERATED BY THIS METHOD SHOULD NOT BE PERSISTED.
     */
    fun createGameEntity(
        maxNumberOfPlayers: Int = 4,
        creator: UserEntity = createUserEntity()
    ): GameEntity {
        return GameEntity(
            creator = creator,
            maxNumberOfPlayers = maxNumberOfPlayers
        )
    }

    /**
     * Instantiates a new [RoundEntity].
     * ENTITIES GENERATED BY THIS METHOD SHOULD NOT BE PERSISTED.
     */
    fun createRoundEntity(
        number: Int = 0,
        game: GameEntity = createGameEntity(),
        dealer: PlayerEntity = createPlayerEntity(),
    ): RoundEntity {
        return RoundEntity(
            game = game,
            dealer = dealer,
            number = number
        )
    }

    /**
     * Instantiates a new [HandEntity].
     * ENTITIES GENERATED BY THIS METHOD SHOULD NOT BE PERSISTED.
     */
    fun createHandEntity(
        index: Int = 0,
        hasMarriage: Boolean = false,
        cards: MutableList<String> = mutableListOf(),
        round: RoundEntity = createRoundEntity(),
        player: PlayerEntity = createPlayerEntity(),
        declaration: Declaration? = null,
        bidding: Bidding? = null,
    ): HandEntity {
        return HandEntity(
            round = round,
            player = player,
            index = index,
            cardsRemaining = cards,
            hasMarriage = hasMarriage
        ).apply {
            declaration?.let { this.declared = it }
            bidding?.let { this.bidding = it }
        }
    }

    /**
     * Instantiates a new [TrickEntity].
     * ENTITIES GENERATED BY THIS METHOD SHOULD NOT BE PERSISTED.
     */
    fun createTrickEntity(
        round: RoundEntity = createRoundEntity(),
        number: Int = 0,
        openIndex: Int = 0,
        demand: CardDemand = CardDemand.HEARTS
    ): TrickEntity {
        return TrickEntity(
            round = round,
            number = number,
            openIndex = openIndex,
            demand = demand
        )
    }

    /**
     * Instantiates a new [TurnEntity].
     * ENTITIES GENERATED BY THIS METHOD SHOULD NOT BE PERSISTED.
     */
    fun createTurnEntity(
        round: RoundEntity = createRoundEntity(),
        hand: HandEntity = createHandEntity(),
        trick: TrickEntity = createTrickEntity(),
        number: Int = 0,
        card: String = "QC0"
    ): TurnEntity {
        return TurnEntity(
            round = round,
            hand = hand,
            trick = trick,
            number = number,
            card = card
        )
    }
}